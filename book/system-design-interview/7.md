# 7장 유일 ID 생성기

ID의 설계방법을 명확하게 알고 가야됨.

숫자로 이루어지는지, 정렬이 가능해야되는지.

그에 따라

- stride 기반 id 할당 (흔히 생각하는 방법)
  - 서버갯수만큼 k씩 뛰어서 저장함.
  - 문제점
    - 보통 이런 방법의 주된 문제인데 (해시에서도) 서버의 갯수가 바뀌었을 때 처리가 어려움. 
    - 전체적으로는 key만으로는 순차를 알기 힘듬.
  - 해결법 (빨간약은 아님)
    - timestamp 도입.

- 티켓 서버 (딱히 생각해 본적 없는 방법)
    - 하나의 서버에서 increment를 해주는 방법.
    - stride 기반 보다는 일관성은 높지만, 안전성이 낮아짐. (spof)
- UUIDv4 (흔히 생각하는 방법)
    - 랜덤 문자열
    - 문제점
        - 순차처리 보장안됨.
        - 문자열로 인해 key가 무거워짐.
- UUIDv1 / UUIDv7 (몰랐음)
    - UUIDv4와 달리 순차 가능

- 스노우 플레이크 (최신에 실무에서 사용해본 방법)
    - 기준시간으로부터의 타임스탬프, 데이터센터, 서버, 숫자 의 조합.
    - 64비트라는 점에서 69년이라는 단점이 있으나..? 128년 uuid를 생각하면 뭐 크게 증가는 가능할 거 같음. 근데 uuidv7보다 명확한 장점이 있는지 모르겠음.

### 느낀 점

사내 서버에서 이중화가 필요해. 고민을 했었다. 이 책을 읽기 전 먼저 저아된 DB 및 서버의 구별이 가능해야된다는 점과 순차처리가 필요해 스노우 플레이크를 선택했었다.  
근데 책을 읽고 나서는 충분한 고민이 부족했다는 걸 깨달았다. 

- 우선 그 당시 69년 정도의 초기화 시점은 고민을 하지 않았고
- worker id를 고정으로 박아버렸다. 이 부분은 분산환경에 익숙치 않아 저지른 일이었다. 어짜피 우리 서비스 같은 경우엔 서버는 곧 db와 같은 구조라 문제가 없었겠지만 서버의 갯수가 바뀌었을 때 문제가 된다는 점은 인식해야 할 거 같다. 
- 추후 Worker ID를 DB에서 자동으로 가져오는 방식으로 수정할 필요가 있다.

### 추후 공부해야 되는 점
- 시계 동기화. 보통 각각의 서버에서 k8s로 pod끼리 시간을 맞추는정도로 넘어갔었는데, 조금 더 학습을 해봐야 할 거 같다.